package oldevents

import (
	"errors"

	"github.com/launchdarkly/go-sdk-common/v3/ldvalue"
	ldevents "github.com/launchdarkly/go-sdk-events/v3"
	"github.com/launchdarkly/go-server-sdk-evaluation/v3/ldmodel"
	"github.com/launchdarkly/go-server-sdk/v7/subsystems"
	"github.com/launchdarkly/go-server-sdk/v7/subsystems/ldstoreimpl"
)

var (
	errEventsBeforeClientInitialized = errors.New("Relay is not ready to process events yet (data store not yet created)") //nolint:stylecheck
)

// TranslateFeatureEvent converts a "feature" event generated by the PHP SDK into the appropriate parameters
// for putting equivalent evaluation information into the new-style event output.
//
// See package comments in package_info.go for more details about this logic.
func TranslateFeatureEvent(
	e FeatureEvent,
	schemaVersion int,
	dataStore subsystems.DataStore,
) (ldevents.EvaluationData, error) {
	evalData := ldevents.EvaluationData{
		BaseEvent: ldevents.BaseEvent{
			CreationDate: e.CreationDate,
			Context:      e.actualContext,
		},
		Key:                  e.Key,
		Version:              e.Version,
		Value:                e.Value,
		Default:              e.Default,
		Reason:               e.Reason,
		SamplingRatio:        e.SamplingRatio, /* Pass along the recorded sampling ratio */
		ForceSampling:        true,            /* Indicate to the event processor that this event must be selected to avoid double-sampling */
		ExcludeFromSummaries: e.ExcludeFromSummaries.BoolValue(),
	}

	if e.Version.IsDefined() {
		evalData.Variation = e.Variation
		if e.TrackEvents.IsDefined() || e.DebugEventsUntilDate != 0 {
			evalData.RequireFullEvent = e.TrackEvents.BoolValue()
			evalData.DebugEventsUntilDate = e.DebugEventsUntilDate
			// These properties are only provided by newer versions of the PHP SDK. In this case we can rely on
			// the SDK to have provided the Variation property as well; it is only much older SDKs that omit
			// Variation.
			return evalData, nil
		}
		// Try to read the flag from the data store to fill in the missing properties.
		if dataStore == nil {
			// The data store has not been created yet. That is pretty much the first thing that happens when
			// the LDClient is created, and the LDClient is created when Relay starts up, so this can only happen
			// if we receive events very early during startup. There's nothing we can do about this, and it's not
			// terribly significant because if the SDK had sent the events a few milliseconds earlier, Relay
			// would've been even less ready to receive them.
			return ldevents.EvaluationData{}, errEventsBeforeClientInitialized
		}
		data, err := dataStore.Get(ldstoreimpl.Features(), e.Key)
		if err != nil {
			return ldevents.EvaluationData{}, err
		}
		if data.Item != nil {
			flag := data.Item.(*ldmodel.FeatureFlag)
			evalData.RequireFullEvent = flag.TrackEvents
			evalData.DebugEventsUntilDate = flag.DebugEventsUntilDate
			// In schema version 1, Variation is never provided, so we'll have to infer it from the variations list.
			// In schema version 2, Variation is always provided-- unless the evaluation failed, in which case it
			// is proper for Variation to be absent.
			if schemaVersion <= 1 && !e.Variation.IsDefined() {
				for i, value := range flag.Variations {
					if value.Equal(e.Value) {
						n := i
						evalData.Variation = ldvalue.NewOptionalInt(n)
						break
					}
				}
			}
		}
	}
	// We've done our best - any missing properties at this point cannot be reconstructed
	return evalData, nil
}

// TranslateIdentifyEvent converts an identify event generated by the PHP SDK into the appropriate parameters
// for generating an identify event in the new-style event output.
func TranslateIdentifyEvent(e IdentifyEvent) (ldevents.IdentifyEventData, error) {
	ret := ldevents.IdentifyEventData{
		BaseEvent: ldevents.BaseEvent{
			CreationDate: e.CreationDate,
			Context:      e.actualContext,
		},
	}
	return ret, nil
}

// TranslateCustomEvent converts a custom event generated by the PHP SDK into the appropriate parameters
// for generating a custom event in the new-style event output.
func TranslateCustomEvent(e CustomEvent) (ldevents.CustomEventData, error) {
	ret := ldevents.CustomEventData{
		BaseEvent: ldevents.BaseEvent{
			CreationDate: e.CreationDate,
			Context:      e.actualContext,
		},
		Key:  e.Key,
		Data: e.Data,
	}
	if e.MetricValue != nil {
		ret.HasMetric = true
		ret.MetricValue = *e.MetricValue
	}
	return ret, nil
}
